// Code generated by protoc-gen-gogo.
// source: sql.proto
// DO NOT EDIT!

/*
	Package rel is a generated protocol buffer package.

	It is generated from these files:
		sql.proto

	It has these top-level messages:
		SqlStatementPb
		SqlSelectPb
		SqlSourcePb
		SqlWherePb
		ProjectionPb
		ResultColumnPb
		KvInt
		ColumnPb
		CommandColumnPb
*/
package rel

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import expr "github.com/araddon/qlbridge/expr"
import _ "github.com/gogo/protobuf/gogoproto"

import github_com_golang_protobuf_proto "github.com/golang/protobuf/proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// The generic SqlStatement, must be exactly one of these types
type SqlStatementPb struct {
	Select           *SqlSelectPb  `protobuf:"bytes,1,opt,name=select" json:"select,omitempty"`
	Source           *SqlSourcePb  `protobuf:"bytes,2,opt,name=source" json:"source,omitempty"`
	Projection       *ProjectionPb `protobuf:"bytes,4,opt,name=projection" json:"projection,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *SqlStatementPb) Reset()         { *m = SqlStatementPb{} }
func (m *SqlStatementPb) String() string { return proto.CompactTextString(m) }
func (*SqlStatementPb) ProtoMessage()    {}

func (m *SqlStatementPb) GetSelect() *SqlSelectPb {
	if m != nil {
		return m.Select
	}
	return nil
}

func (m *SqlStatementPb) GetSource() *SqlSourcePb {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *SqlStatementPb) GetProjection() *ProjectionPb {
	if m != nil {
		return m.Projection
	}
	return nil
}

type SqlSelectPb struct {
	Db               string         `protobuf:"bytes,1,req,name=db" json:"db"`
	Raw              string         `protobuf:"bytes,2,req,name=raw" json:"raw"`
	Star             bool           `protobuf:"varint,3,req,name=star" json:"star"`
	Distinct         bool           `protobuf:"varint,4,req,name=distinct" json:"distinct"`
	Columns          []*ColumnPb    `protobuf:"bytes,5,rep,name=columns" json:"columns,omitempty"`
	From             []*SqlSourcePb `protobuf:"bytes,6,rep,name=from" json:"from,omitempty"`
	Into             *string        `protobuf:"bytes,7,opt,name=into" json:"into,omitempty"`
	Where            *SqlWherePb    `protobuf:"bytes,8,opt,name=where" json:"where,omitempty"`
	Having           *expr.NodePb   `protobuf:"bytes,9,opt,name=having" json:"having,omitempty"`
	GroupBy          []*ColumnPb    `protobuf:"bytes,11,rep,name=groupBy" json:"groupBy,omitempty"`
	OrderBy          []*ColumnPb    `protobuf:"bytes,10,rep,name=orderBy" json:"orderBy,omitempty"`
	Limit            int32          `protobuf:"varint,12,opt,name=limit" json:"limit"`
	Offset           int32          `protobuf:"varint,13,opt,name=offset" json:"offset"`
	Alias            *string        `protobuf:"bytes,14,opt,name=alias" json:"alias,omitempty"`
	Projection       *ProjectionPb  `protobuf:"bytes,15,opt,name=projection" json:"projection,omitempty"`
	IsAgg            bool           `protobuf:"varint,16,req,name=isAgg" json:"isAgg"`
	Finalized        bool           `protobuf:"varint,17,req,name=finalized" json:"finalized"`
	Schemaqry        bool           `protobuf:"varint,18,req,name=schemaqry" json:"schemaqry"`
	With             []byte         `protobuf:"bytes,19,opt,name=with" json:"with,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *SqlSelectPb) Reset()         { *m = SqlSelectPb{} }
func (m *SqlSelectPb) String() string { return proto.CompactTextString(m) }
func (*SqlSelectPb) ProtoMessage()    {}

func (m *SqlSelectPb) GetDb() string {
	if m != nil {
		return m.Db
	}
	return ""
}

func (m *SqlSelectPb) GetRaw() string {
	if m != nil {
		return m.Raw
	}
	return ""
}

func (m *SqlSelectPb) GetStar() bool {
	if m != nil {
		return m.Star
	}
	return false
}

func (m *SqlSelectPb) GetDistinct() bool {
	if m != nil {
		return m.Distinct
	}
	return false
}

func (m *SqlSelectPb) GetColumns() []*ColumnPb {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *SqlSelectPb) GetFrom() []*SqlSourcePb {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *SqlSelectPb) GetInto() string {
	if m != nil && m.Into != nil {
		return *m.Into
	}
	return ""
}

func (m *SqlSelectPb) GetWhere() *SqlWherePb {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *SqlSelectPb) GetHaving() *expr.NodePb {
	if m != nil {
		return m.Having
	}
	return nil
}

func (m *SqlSelectPb) GetGroupBy() []*ColumnPb {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *SqlSelectPb) GetOrderBy() []*ColumnPb {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *SqlSelectPb) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SqlSelectPb) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *SqlSelectPb) GetAlias() string {
	if m != nil && m.Alias != nil {
		return *m.Alias
	}
	return ""
}

func (m *SqlSelectPb) GetProjection() *ProjectionPb {
	if m != nil {
		return m.Projection
	}
	return nil
}

func (m *SqlSelectPb) GetIsAgg() bool {
	if m != nil {
		return m.IsAgg
	}
	return false
}

func (m *SqlSelectPb) GetFinalized() bool {
	if m != nil {
		return m.Finalized
	}
	return false
}

func (m *SqlSelectPb) GetSchemaqry() bool {
	if m != nil {
		return m.Schemaqry
	}
	return false
}

func (m *SqlSelectPb) GetWith() []byte {
	if m != nil {
		return m.With
	}
	return nil
}

type SqlSourcePb struct {
	Final            bool           `protobuf:"varint,1,opt,name=final" json:"final"`
	AliasInner       *string        `protobuf:"bytes,2,opt,name=aliasInner" json:"aliasInner,omitempty"`
	Columns          []*ColumnPb    `protobuf:"bytes,3,rep,name=columns" json:"columns,omitempty"`
	ColIndex         []KvInt        `protobuf:"bytes,4,rep,name=colIndex" json:"colIndex"`
	JoinNodes        []*expr.NodePb `protobuf:"bytes,5,rep,name=joinNodes" json:"joinNodes,omitempty"`
	Source           *SqlSelectPb   `protobuf:"bytes,6,opt,name=source" json:"source,omitempty"`
	Raw              string         `protobuf:"bytes,7,opt,name=raw" json:"raw"`
	Name             string         `protobuf:"bytes,8,opt,name=name" json:"name"`
	Alias            string         `protobuf:"bytes,9,opt,name=alias" json:"alias"`
	Op               int32          `protobuf:"varint,10,req,name=op" json:"op"`
	LeftOrRight      int32          `protobuf:"varint,11,req,name=leftOrRight" json:"leftOrRight"`
	JoinType         int32          `protobuf:"varint,12,req,name=joinType" json:"joinType"`
	JoinExpr         *expr.NodePb   `protobuf:"bytes,13,opt,name=joinExpr" json:"joinExpr,omitempty"`
	SubQuery         *SqlSelectPb   `protobuf:"bytes,14,opt,name=subQuery" json:"subQuery,omitempty"`
	Seekable         bool           `protobuf:"varint,15,opt,name=seekable" json:"seekable"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *SqlSourcePb) Reset()         { *m = SqlSourcePb{} }
func (m *SqlSourcePb) String() string { return proto.CompactTextString(m) }
func (*SqlSourcePb) ProtoMessage()    {}

func (m *SqlSourcePb) GetFinal() bool {
	if m != nil {
		return m.Final
	}
	return false
}

func (m *SqlSourcePb) GetAliasInner() string {
	if m != nil && m.AliasInner != nil {
		return *m.AliasInner
	}
	return ""
}

func (m *SqlSourcePb) GetColumns() []*ColumnPb {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *SqlSourcePb) GetColIndex() []KvInt {
	if m != nil {
		return m.ColIndex
	}
	return nil
}

func (m *SqlSourcePb) GetJoinNodes() []*expr.NodePb {
	if m != nil {
		return m.JoinNodes
	}
	return nil
}

func (m *SqlSourcePb) GetSource() *SqlSelectPb {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *SqlSourcePb) GetRaw() string {
	if m != nil {
		return m.Raw
	}
	return ""
}

func (m *SqlSourcePb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SqlSourcePb) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *SqlSourcePb) GetOp() int32 {
	if m != nil {
		return m.Op
	}
	return 0
}

func (m *SqlSourcePb) GetLeftOrRight() int32 {
	if m != nil {
		return m.LeftOrRight
	}
	return 0
}

func (m *SqlSourcePb) GetJoinType() int32 {
	if m != nil {
		return m.JoinType
	}
	return 0
}

func (m *SqlSourcePb) GetJoinExpr() *expr.NodePb {
	if m != nil {
		return m.JoinExpr
	}
	return nil
}

func (m *SqlSourcePb) GetSubQuery() *SqlSelectPb {
	if m != nil {
		return m.SubQuery
	}
	return nil
}

func (m *SqlSourcePb) GetSeekable() bool {
	if m != nil {
		return m.Seekable
	}
	return false
}

type SqlWherePb struct {
	Op               int32        `protobuf:"varint,1,req,name=op" json:"op"`
	Source           *SqlSelectPb `protobuf:"bytes,2,opt,name=source" json:"source,omitempty"`
	Expr             *expr.NodePb `protobuf:"bytes,3,opt,name=Expr" json:"Expr,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *SqlWherePb) Reset()         { *m = SqlWherePb{} }
func (m *SqlWherePb) String() string { return proto.CompactTextString(m) }
func (*SqlWherePb) ProtoMessage()    {}

func (m *SqlWherePb) GetOp() int32 {
	if m != nil {
		return m.Op
	}
	return 0
}

func (m *SqlWherePb) GetSource() *SqlSelectPb {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *SqlWherePb) GetExpr() *expr.NodePb {
	if m != nil {
		return m.Expr
	}
	return nil
}

type ProjectionPb struct {
	Distinct         bool              `protobuf:"varint,1,req,name=distinct" json:"distinct"`
	ColNames         []string          `protobuf:"bytes,2,rep,name=colNames" json:"colNames,omitempty"`
	Columns          []*ResultColumnPb `protobuf:"bytes,3,rep,name=columns" json:"columns,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *ProjectionPb) Reset()         { *m = ProjectionPb{} }
func (m *ProjectionPb) String() string { return proto.CompactTextString(m) }
func (*ProjectionPb) ProtoMessage()    {}

func (m *ProjectionPb) GetDistinct() bool {
	if m != nil {
		return m.Distinct
	}
	return false
}

func (m *ProjectionPb) GetColNames() []string {
	if m != nil {
		return m.ColNames
	}
	return nil
}

func (m *ProjectionPb) GetColumns() []*ResultColumnPb {
	if m != nil {
		return m.Columns
	}
	return nil
}

type ResultColumnPb struct {
	Final            *bool     `protobuf:"varint,1,opt,name=final" json:"final,omitempty"`
	Name             string    `protobuf:"bytes,2,req,name=name" json:"name"`
	ColPos           int32     `protobuf:"varint,3,req,name=colPos" json:"colPos"`
	Column           *ColumnPb `protobuf:"bytes,4,req,name=column" json:"column,omitempty"`
	Star             *bool     `protobuf:"varint,5,opt,name=star" json:"star,omitempty"`
	As               string    `protobuf:"bytes,6,req,name=as" json:"as"`
	ValueType        int32     `protobuf:"varint,7,req,name=valueType" json:"valueType"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *ResultColumnPb) Reset()         { *m = ResultColumnPb{} }
func (m *ResultColumnPb) String() string { return proto.CompactTextString(m) }
func (*ResultColumnPb) ProtoMessage()    {}

func (m *ResultColumnPb) GetFinal() bool {
	if m != nil && m.Final != nil {
		return *m.Final
	}
	return false
}

func (m *ResultColumnPb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ResultColumnPb) GetColPos() int32 {
	if m != nil {
		return m.ColPos
	}
	return 0
}

func (m *ResultColumnPb) GetColumn() *ColumnPb {
	if m != nil {
		return m.Column
	}
	return nil
}

func (m *ResultColumnPb) GetStar() bool {
	if m != nil && m.Star != nil {
		return *m.Star
	}
	return false
}

func (m *ResultColumnPb) GetAs() string {
	if m != nil {
		return m.As
	}
	return ""
}

func (m *ResultColumnPb) GetValueType() int32 {
	if m != nil {
		return m.ValueType
	}
	return 0
}

type KvInt struct {
	K                string `protobuf:"bytes,1,req,name=k" json:"k"`
	V                int32  `protobuf:"varint,2,req,name=v" json:"v"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *KvInt) Reset()         { *m = KvInt{} }
func (m *KvInt) String() string { return proto.CompactTextString(m) }
func (*KvInt) ProtoMessage()    {}

func (m *KvInt) GetK() string {
	if m != nil {
		return m.K
	}
	return ""
}

func (m *KvInt) GetV() int32 {
	if m != nil {
		return m.V
	}
	return 0
}

type ColumnPb struct {
	SourceQuote      []byte       `protobuf:"bytes,1,opt,name=sourceQuote" json:"sourceQuote,omitempty"`
	AsQuoteByte      []byte       `protobuf:"bytes,2,opt,name=asQuoteByte" json:"asQuoteByte,omitempty"`
	OriginalAs       *string      `protobuf:"bytes,3,opt,name=originalAs" json:"originalAs,omitempty"`
	Left             *string      `protobuf:"bytes,4,opt,name=left" json:"left,omitempty"`
	Right            *string      `protobuf:"bytes,5,opt,name=right" json:"right,omitempty"`
	ParentIndex      int32        `protobuf:"varint,6,opt,name=parentIndex" json:"parentIndex"`
	Index            int32        `protobuf:"varint,7,opt,name=index" json:"index"`
	SourceIndex      int32        `protobuf:"varint,8,opt,name=sourceIndex" json:"sourceIndex"`
	SourceField      *string      `protobuf:"bytes,9,opt,name=sourceField" json:"sourceField,omitempty"`
	As               string       `protobuf:"bytes,11,opt,name=as" json:"as"`
	Comment          *string      `protobuf:"bytes,12,opt,name=comment" json:"comment,omitempty"`
	Order            *string      `protobuf:"bytes,13,opt,name=order" json:"order,omitempty"`
	Star             *bool        `protobuf:"varint,14,opt,name=star" json:"star,omitempty"`
	Agg              bool         `protobuf:"varint,15,opt,name=agg" json:"agg"`
	Expr             *expr.NodePb `protobuf:"bytes,16,opt,name=Expr" json:"Expr,omitempty"`
	Guard            *expr.NodePb `protobuf:"bytes,17,opt,name=Guard" json:"Guard,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *ColumnPb) Reset()         { *m = ColumnPb{} }
func (m *ColumnPb) String() string { return proto.CompactTextString(m) }
func (*ColumnPb) ProtoMessage()    {}

func (m *ColumnPb) GetSourceQuote() []byte {
	if m != nil {
		return m.SourceQuote
	}
	return nil
}

func (m *ColumnPb) GetAsQuoteByte() []byte {
	if m != nil {
		return m.AsQuoteByte
	}
	return nil
}

func (m *ColumnPb) GetOriginalAs() string {
	if m != nil && m.OriginalAs != nil {
		return *m.OriginalAs
	}
	return ""
}

func (m *ColumnPb) GetLeft() string {
	if m != nil && m.Left != nil {
		return *m.Left
	}
	return ""
}

func (m *ColumnPb) GetRight() string {
	if m != nil && m.Right != nil {
		return *m.Right
	}
	return ""
}

func (m *ColumnPb) GetParentIndex() int32 {
	if m != nil {
		return m.ParentIndex
	}
	return 0
}

func (m *ColumnPb) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *ColumnPb) GetSourceIndex() int32 {
	if m != nil {
		return m.SourceIndex
	}
	return 0
}

func (m *ColumnPb) GetSourceField() string {
	if m != nil && m.SourceField != nil {
		return *m.SourceField
	}
	return ""
}

func (m *ColumnPb) GetAs() string {
	if m != nil {
		return m.As
	}
	return ""
}

func (m *ColumnPb) GetComment() string {
	if m != nil && m.Comment != nil {
		return *m.Comment
	}
	return ""
}

func (m *ColumnPb) GetOrder() string {
	if m != nil && m.Order != nil {
		return *m.Order
	}
	return ""
}

func (m *ColumnPb) GetStar() bool {
	if m != nil && m.Star != nil {
		return *m.Star
	}
	return false
}

func (m *ColumnPb) GetAgg() bool {
	if m != nil {
		return m.Agg
	}
	return false
}

func (m *ColumnPb) GetExpr() *expr.NodePb {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *ColumnPb) GetGuard() *expr.NodePb {
	if m != nil {
		return m.Guard
	}
	return nil
}

type CommandColumnPb struct {
	Expr             *expr.NodePb `protobuf:"bytes,1,opt,name=Expr" json:"Expr,omitempty"`
	Name             string       `protobuf:"bytes,2,req,name=name" json:"name"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *CommandColumnPb) Reset()         { *m = CommandColumnPb{} }
func (m *CommandColumnPb) String() string { return proto.CompactTextString(m) }
func (*CommandColumnPb) ProtoMessage()    {}

func (m *CommandColumnPb) GetExpr() *expr.NodePb {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *CommandColumnPb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func init() {
	proto.RegisterType((*SqlStatementPb)(nil), "rel.SqlStatementPb")
	proto.RegisterType((*SqlSelectPb)(nil), "rel.SqlSelectPb")
	proto.RegisterType((*SqlSourcePb)(nil), "rel.SqlSourcePb")
	proto.RegisterType((*SqlWherePb)(nil), "rel.SqlWherePb")
	proto.RegisterType((*ProjectionPb)(nil), "rel.ProjectionPb")
	proto.RegisterType((*ResultColumnPb)(nil), "rel.ResultColumnPb")
	proto.RegisterType((*KvInt)(nil), "rel.KvInt")
	proto.RegisterType((*ColumnPb)(nil), "rel.ColumnPb")
	proto.RegisterType((*CommandColumnPb)(nil), "rel.CommandColumnPb")
}
func (m *SqlStatementPb) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SqlStatementPb) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Select != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSql(data, i, uint64(m.Select.Size()))
		n1, err := m.Select.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Source != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSql(data, i, uint64(m.Source.Size()))
		n2, err := m.Source.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Projection != nil {
		data[i] = 0x22
		i++
		i = encodeVarintSql(data, i, uint64(m.Projection.Size()))
		n3, err := m.Projection.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SqlSelectPb) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SqlSelectPb) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSql(data, i, uint64(len(m.Db)))
	i += copy(data[i:], m.Db)
	data[i] = 0x12
	i++
	i = encodeVarintSql(data, i, uint64(len(m.Raw)))
	i += copy(data[i:], m.Raw)
	data[i] = 0x18
	i++
	if m.Star {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	data[i] = 0x20
	i++
	if m.Distinct {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			data[i] = 0x2a
			i++
			i = encodeVarintSql(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.From) > 0 {
		for _, msg := range m.From {
			data[i] = 0x32
			i++
			i = encodeVarintSql(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Into != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintSql(data, i, uint64(len(*m.Into)))
		i += copy(data[i:], *m.Into)
	}
	if m.Where != nil {
		data[i] = 0x42
		i++
		i = encodeVarintSql(data, i, uint64(m.Where.Size()))
		n4, err := m.Where.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Having != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintSql(data, i, uint64(m.Having.Size()))
		n5, err := m.Having.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.OrderBy) > 0 {
		for _, msg := range m.OrderBy {
			data[i] = 0x52
			i++
			i = encodeVarintSql(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GroupBy) > 0 {
		for _, msg := range m.GroupBy {
			data[i] = 0x5a
			i++
			i = encodeVarintSql(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x60
	i++
	i = encodeVarintSql(data, i, uint64(m.Limit))
	data[i] = 0x68
	i++
	i = encodeVarintSql(data, i, uint64(m.Offset))
	if m.Alias != nil {
		data[i] = 0x72
		i++
		i = encodeVarintSql(data, i, uint64(len(*m.Alias)))
		i += copy(data[i:], *m.Alias)
	}
	if m.Projection != nil {
		data[i] = 0x7a
		i++
		i = encodeVarintSql(data, i, uint64(m.Projection.Size()))
		n6, err := m.Projection.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	data[i] = 0x80
	i++
	data[i] = 0x1
	i++
	if m.IsAgg {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	data[i] = 0x88
	i++
	data[i] = 0x1
	i++
	if m.Finalized {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	data[i] = 0x90
	i++
	data[i] = 0x1
	i++
	if m.Schemaqry {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	if m.With != nil {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSql(data, i, uint64(len(m.With)))
		i += copy(data[i:], m.With)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SqlSourcePb) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SqlSourcePb) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	if m.Final {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	if m.AliasInner != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSql(data, i, uint64(len(*m.AliasInner)))
		i += copy(data[i:], *m.AliasInner)
	}
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			data[i] = 0x1a
			i++
			i = encodeVarintSql(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ColIndex) > 0 {
		for _, msg := range m.ColIndex {
			data[i] = 0x22
			i++
			i = encodeVarintSql(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.JoinNodes) > 0 {
		for _, msg := range m.JoinNodes {
			data[i] = 0x2a
			i++
			i = encodeVarintSql(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Source != nil {
		data[i] = 0x32
		i++
		i = encodeVarintSql(data, i, uint64(m.Source.Size()))
		n7, err := m.Source.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	data[i] = 0x3a
	i++
	i = encodeVarintSql(data, i, uint64(len(m.Raw)))
	i += copy(data[i:], m.Raw)
	data[i] = 0x42
	i++
	i = encodeVarintSql(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	data[i] = 0x4a
	i++
	i = encodeVarintSql(data, i, uint64(len(m.Alias)))
	i += copy(data[i:], m.Alias)
	data[i] = 0x50
	i++
	i = encodeVarintSql(data, i, uint64(m.Op))
	data[i] = 0x58
	i++
	i = encodeVarintSql(data, i, uint64(m.LeftOrRight))
	data[i] = 0x60
	i++
	i = encodeVarintSql(data, i, uint64(m.JoinType))
	if m.JoinExpr != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintSql(data, i, uint64(m.JoinExpr.Size()))
		n8, err := m.JoinExpr.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.SubQuery != nil {
		data[i] = 0x72
		i++
		i = encodeVarintSql(data, i, uint64(m.SubQuery.Size()))
		n9, err := m.SubQuery.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	data[i] = 0x78
	i++
	if m.Seekable {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SqlWherePb) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SqlWherePb) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintSql(data, i, uint64(m.Op))
	if m.Source != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSql(data, i, uint64(m.Source.Size()))
		n10, err := m.Source.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Expr != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSql(data, i, uint64(m.Expr.Size()))
		n11, err := m.Expr.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProjectionPb) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProjectionPb) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	if m.Distinct {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	if len(m.ColNames) > 0 {
		for _, s := range m.ColNames {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			data[i] = 0x1a
			i++
			i = encodeVarintSql(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResultColumnPb) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ResultColumnPb) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Final != nil {
		data[i] = 0x8
		i++
		if *m.Final {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	data[i] = 0x12
	i++
	i = encodeVarintSql(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	data[i] = 0x18
	i++
	i = encodeVarintSql(data, i, uint64(m.ColPos))
	if m.Column == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x22
		i++
		i = encodeVarintSql(data, i, uint64(m.Column.Size()))
		n12, err := m.Column.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Star != nil {
		data[i] = 0x28
		i++
		if *m.Star {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	data[i] = 0x32
	i++
	i = encodeVarintSql(data, i, uint64(len(m.As)))
	i += copy(data[i:], m.As)
	data[i] = 0x38
	i++
	i = encodeVarintSql(data, i, uint64(m.ValueType))
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KvInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *KvInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSql(data, i, uint64(len(m.K)))
	i += copy(data[i:], m.K)
	data[i] = 0x10
	i++
	i = encodeVarintSql(data, i, uint64(m.V))
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ColumnPb) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ColumnPb) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SourceQuote != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSql(data, i, uint64(len(m.SourceQuote)))
		i += copy(data[i:], m.SourceQuote)
	}
	if m.AsQuoteByte != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSql(data, i, uint64(len(m.AsQuoteByte)))
		i += copy(data[i:], m.AsQuoteByte)
	}
	if m.OriginalAs != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSql(data, i, uint64(len(*m.OriginalAs)))
		i += copy(data[i:], *m.OriginalAs)
	}
	if m.Left != nil {
		data[i] = 0x22
		i++
		i = encodeVarintSql(data, i, uint64(len(*m.Left)))
		i += copy(data[i:], *m.Left)
	}
	if m.Right != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintSql(data, i, uint64(len(*m.Right)))
		i += copy(data[i:], *m.Right)
	}
	data[i] = 0x30
	i++
	i = encodeVarintSql(data, i, uint64(m.ParentIndex))
	data[i] = 0x38
	i++
	i = encodeVarintSql(data, i, uint64(m.Index))
	data[i] = 0x40
	i++
	i = encodeVarintSql(data, i, uint64(m.SourceIndex))
	if m.SourceField != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintSql(data, i, uint64(len(*m.SourceField)))
		i += copy(data[i:], *m.SourceField)
	}
	data[i] = 0x5a
	i++
	i = encodeVarintSql(data, i, uint64(len(m.As)))
	i += copy(data[i:], m.As)
	if m.Comment != nil {
		data[i] = 0x62
		i++
		i = encodeVarintSql(data, i, uint64(len(*m.Comment)))
		i += copy(data[i:], *m.Comment)
	}
	if m.Order != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintSql(data, i, uint64(len(*m.Order)))
		i += copy(data[i:], *m.Order)
	}
	if m.Star != nil {
		data[i] = 0x70
		i++
		if *m.Star {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	data[i] = 0x78
	i++
	if m.Agg {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	if m.Expr != nil {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSql(data, i, uint64(m.Expr.Size()))
		n13, err := m.Expr.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Guard != nil {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSql(data, i, uint64(m.Guard.Size()))
		n14, err := m.Guard.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandColumnPb) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CommandColumnPb) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Expr != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSql(data, i, uint64(m.Expr.Size()))
		n15, err := m.Expr.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	data[i] = 0x12
	i++
	i = encodeVarintSql(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64Sql(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Sql(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintSql(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *SqlStatementPb) Size() (n int) {
	var l int
	_ = l
	if m.Select != nil {
		l = m.Select.Size()
		n += 1 + l + sovSql(uint64(l))
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovSql(uint64(l))
	}
	if m.Projection != nil {
		l = m.Projection.Size()
		n += 1 + l + sovSql(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SqlSelectPb) Size() (n int) {
	var l int
	_ = l
	l = len(m.Db)
	n += 1 + l + sovSql(uint64(l))
	l = len(m.Raw)
	n += 1 + l + sovSql(uint64(l))
	n += 2
	n += 2
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovSql(uint64(l))
		}
	}
	if len(m.From) > 0 {
		for _, e := range m.From {
			l = e.Size()
			n += 1 + l + sovSql(uint64(l))
		}
	}
	if m.Into != nil {
		l = len(*m.Into)
		n += 1 + l + sovSql(uint64(l))
	}
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovSql(uint64(l))
	}
	if m.Having != nil {
		l = m.Having.Size()
		n += 1 + l + sovSql(uint64(l))
	}
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.Size()
			n += 1 + l + sovSql(uint64(l))
		}
	}
	if len(m.GroupBy) > 0 {
		for _, e := range m.GroupBy {
			l = e.Size()
			n += 1 + l + sovSql(uint64(l))
		}
	}
	n += 1 + sovSql(uint64(m.Limit))
	n += 1 + sovSql(uint64(m.Offset))
	if m.Alias != nil {
		l = len(*m.Alias)
		n += 1 + l + sovSql(uint64(l))
	}
	if m.Projection != nil {
		l = m.Projection.Size()
		n += 1 + l + sovSql(uint64(l))
	}
	n += 3
	n += 3
	n += 3
	if m.With != nil {
		l = len(m.With)
		n += 2 + l + sovSql(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SqlSourcePb) Size() (n int) {
	var l int
	_ = l
	n += 2
	if m.AliasInner != nil {
		l = len(*m.AliasInner)
		n += 1 + l + sovSql(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovSql(uint64(l))
		}
	}
	if len(m.ColIndex) > 0 {
		for _, e := range m.ColIndex {
			l = e.Size()
			n += 1 + l + sovSql(uint64(l))
		}
	}
	if len(m.JoinNodes) > 0 {
		for _, e := range m.JoinNodes {
			l = e.Size()
			n += 1 + l + sovSql(uint64(l))
		}
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovSql(uint64(l))
	}
	l = len(m.Raw)
	n += 1 + l + sovSql(uint64(l))
	l = len(m.Name)
	n += 1 + l + sovSql(uint64(l))
	l = len(m.Alias)
	n += 1 + l + sovSql(uint64(l))
	n += 1 + sovSql(uint64(m.Op))
	n += 1 + sovSql(uint64(m.LeftOrRight))
	n += 1 + sovSql(uint64(m.JoinType))
	if m.JoinExpr != nil {
		l = m.JoinExpr.Size()
		n += 1 + l + sovSql(uint64(l))
	}
	if m.SubQuery != nil {
		l = m.SubQuery.Size()
		n += 1 + l + sovSql(uint64(l))
	}
	n += 2
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SqlWherePb) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSql(uint64(m.Op))
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovSql(uint64(l))
	}
	if m.Expr != nil {
		l = m.Expr.Size()
		n += 1 + l + sovSql(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProjectionPb) Size() (n int) {
	var l int
	_ = l
	n += 2
	if len(m.ColNames) > 0 {
		for _, s := range m.ColNames {
			l = len(s)
			n += 1 + l + sovSql(uint64(l))
		}
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovSql(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultColumnPb) Size() (n int) {
	var l int
	_ = l
	if m.Final != nil {
		n += 2
	}
	l = len(m.Name)
	n += 1 + l + sovSql(uint64(l))
	n += 1 + sovSql(uint64(m.ColPos))
	if m.Column != nil {
		l = m.Column.Size()
		n += 1 + l + sovSql(uint64(l))
	}
	if m.Star != nil {
		n += 2
	}
	l = len(m.As)
	n += 1 + l + sovSql(uint64(l))
	n += 1 + sovSql(uint64(m.ValueType))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KvInt) Size() (n int) {
	var l int
	_ = l
	l = len(m.K)
	n += 1 + l + sovSql(uint64(l))
	n += 1 + sovSql(uint64(m.V))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColumnPb) Size() (n int) {
	var l int
	_ = l
	if m.SourceQuote != nil {
		l = len(m.SourceQuote)
		n += 1 + l + sovSql(uint64(l))
	}
	if m.AsQuoteByte != nil {
		l = len(m.AsQuoteByte)
		n += 1 + l + sovSql(uint64(l))
	}
	if m.OriginalAs != nil {
		l = len(*m.OriginalAs)
		n += 1 + l + sovSql(uint64(l))
	}
	if m.Left != nil {
		l = len(*m.Left)
		n += 1 + l + sovSql(uint64(l))
	}
	if m.Right != nil {
		l = len(*m.Right)
		n += 1 + l + sovSql(uint64(l))
	}
	n += 1 + sovSql(uint64(m.ParentIndex))
	n += 1 + sovSql(uint64(m.Index))
	n += 1 + sovSql(uint64(m.SourceIndex))
	if m.SourceField != nil {
		l = len(*m.SourceField)
		n += 1 + l + sovSql(uint64(l))
	}
	l = len(m.As)
	n += 1 + l + sovSql(uint64(l))
	if m.Comment != nil {
		l = len(*m.Comment)
		n += 1 + l + sovSql(uint64(l))
	}
	if m.Order != nil {
		l = len(*m.Order)
		n += 1 + l + sovSql(uint64(l))
	}
	if m.Star != nil {
		n += 2
	}
	n += 2
	if m.Expr != nil {
		l = m.Expr.Size()
		n += 2 + l + sovSql(uint64(l))
	}
	if m.Guard != nil {
		l = m.Guard.Size()
		n += 2 + l + sovSql(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandColumnPb) Size() (n int) {
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.Size()
		n += 1 + l + sovSql(uint64(l))
	}
	l = len(m.Name)
	n += 1 + l + sovSql(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSql(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSql(x uint64) (n int) {
	return sovSql(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SqlStatementPb) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SqlStatementPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SqlStatementPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Select", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Select == nil {
				m.Select = &SqlSelectPb{}
			}
			if err := m.Select.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &SqlSourcePb{}
			}
			if err := m.Source.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Projection == nil {
				m.Projection = &ProjectionPb{}
			}
			if err := m.Projection.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSql(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlSelectPb) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SqlSelectPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SqlSelectPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Db", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Db = string(data[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Raw = string(data[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Star = bool(v != 0)
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distinct", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Distinct = bool(v != 0)
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &ColumnPb{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = append(m.From, &SqlSourcePb{})
			if err := m.From[len(m.From)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Into", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Into = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &SqlWherePb{}
			}
			if err := m.Where.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Having", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Having == nil {
				m.Having = &expr.NodePb{}
			}
			if err := m.Having.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, &ColumnPb{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = append(m.GroupBy, &ColumnPb{})
			if err := m.GroupBy[len(m.GroupBy)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Alias = &s
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Projection == nil {
				m.Projection = &ProjectionPb{}
			}
			if err := m.Projection.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAgg", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAgg = bool(v != 0)
			hasFields[0] |= uint64(0x00000010)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalized", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Finalized = bool(v != 0)
			hasFields[0] |= uint64(0x00000020)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemaqry", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Schemaqry = bool(v != 0)
			hasFields[0] |= uint64(0x00000040)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field With", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.With = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSql(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlSourcePb) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SqlSourcePb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SqlSourcePb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Final", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Final = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasInner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.AliasInner = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &ColumnPb{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColIndex = append(m.ColIndex, KvInt{})
			if err := m.ColIndex[len(m.ColIndex)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JoinNodes = append(m.JoinNodes, &expr.NodePb{})
			if err := m.JoinNodes[len(m.JoinNodes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &SqlSelectPb{}
			}
			if err := m.Source.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Raw = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Op |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftOrRight", wireType)
			}
			m.LeftOrRight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LeftOrRight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinType", wireType)
			}
			m.JoinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.JoinType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JoinExpr == nil {
				m.JoinExpr = &expr.NodePb{}
			}
			if err := m.JoinExpr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubQuery == nil {
				m.SubQuery = &SqlSelectPb{}
			}
			if err := m.SubQuery.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seekable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Seekable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSql(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlWherePb) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SqlWherePb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SqlWherePb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Op |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &SqlSelectPb{}
			}
			if err := m.Source.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &expr.NodePb{}
			}
			if err := m.Expr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSql(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProjectionPb) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProjectionPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProjectionPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distinct", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Distinct = bool(v != 0)
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColNames = append(m.ColNames, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &ResultColumnPb{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSql(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultColumnPb) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultColumnPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultColumnPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Final", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Final = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColPos", wireType)
			}
			m.ColPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ColPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Column == nil {
				m.Column = &ColumnPb{}
			}
			if err := m.Column.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Star = &b
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field As", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.As = string(data[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueType", wireType)
			}
			m.ValueType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ValueType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		default:
			iNdEx = preIndex
			skippy, err := skipSql(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KvInt) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KvInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KvInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.K = string(data[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			m.V = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.V |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipSql(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnPb) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceQuote", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceQuote = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsQuoteByte", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsQuoteByte = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalAs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.OriginalAs = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Left = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Right = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentIndex", wireType)
			}
			m.ParentIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ParentIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIndex", wireType)
			}
			m.SourceIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SourceIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceField", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.SourceField = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field As", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.As = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Comment = &s
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Order = &s
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Star = &b
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Agg", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Agg = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &expr.NodePb{}
			}
			if err := m.Expr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Guard == nil {
				m.Guard = &expr.NodePb{}
			}
			if err := m.Guard.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSql(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandColumnPb) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandColumnPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandColumnPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &expr.NodePb{}
			}
			if err := m.Expr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipSql(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSql(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSql
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSql
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSql
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSql
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSql
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSql(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSql = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSql   = fmt.Errorf("proto: integer overflow")
)
